/**
 * Monol Rulebook - Claude Adapter
 *
 * .claude/rules/ 디렉토리 동기화 어댑터
 */
import * as fs from 'fs/promises';
import * as path from 'path';
import { BasePlatformAdapter, getSeverityIcon, registerAdapter, } from './platform-adapter.js';
// ============================================================================
// Claude Adapter
// ============================================================================
export class ClaudeAdapter extends BasePlatformAdapter {
    name = 'claude';
    outputDir = '.claude/rules';
    getOutputPath() {
        return path.join(this.basePath, this.outputDir);
    }
    async read() {
        try {
            const rulesDir = this.getOutputPath();
            const files = await fs.readdir(rulesDir);
            const contents = [];
            for (const file of files) {
                if (file.endsWith('.md') || file.endsWith('.mdc')) {
                    const content = await fs.readFile(path.join(rulesDir, file), 'utf-8');
                    contents.push(content);
                }
            }
            return contents.join('\n\n---\n\n');
        }
        catch {
            return '';
        }
    }
    format(rules) {
        // Claude에서 활성화된 규칙만 필터링
        const claudeRules = rules.filter(r => r.enabled !== false &&
            (r.platforms?.claude?.enabled !== false || !r.platforms));
        // 카테고리별로 그룹화하여 파일 생성할 것이므로
        // 여기서는 전체 내용을 하나의 문자열로 반환
        return this.formatAllRules(claudeRules);
    }
    async write(content) {
        // 이 메서드는 단일 파일용이지만,
        // Claude 어댑터는 여러 파일을 생성하므로 syncMultiple 사용 권장
        const outputPath = path.join(this.getOutputPath(), 'rules.md');
        await this.ensureDir(outputPath);
        await fs.writeFile(outputPath, content, 'utf-8');
    }
    /**
     * 카테고리별로 여러 파일 생성
     */
    async syncMultiple(rules) {
        const claudeRules = rules.filter(r => r.enabled !== false &&
            (r.platforms?.claude?.enabled !== false || !r.platforms));
        const rulesDir = this.getOutputPath();
        await fs.mkdir(rulesDir, { recursive: true });
        const files = [];
        const errors = [];
        // 1. 인덱스 파일 생성
        try {
            const indexContent = this.formatIndex(claudeRules);
            const indexPath = path.join(rulesDir, '_index.md');
            await fs.writeFile(indexPath, indexContent, 'utf-8');
            files.push(indexPath);
        }
        catch (e) {
            errors.push(`Failed to create index: ${e}`);
        }
        // 2. 카테고리별 파일 생성
        const byCategory = new Map();
        for (const rule of claudeRules) {
            const category = rule.category.split('/')[0];
            if (!byCategory.has(category)) {
                byCategory.set(category, []);
            }
            byCategory.get(category).push(rule);
        }
        for (const [category, catRules] of byCategory) {
            try {
                const content = this.formatCategory(category, catRules);
                const fileName = `${category}.mdc`;
                const filePath = path.join(rulesDir, fileName);
                await fs.writeFile(filePath, content, 'utf-8');
                files.push(filePath);
            }
            catch (e) {
                errors.push(`Failed to create ${category}: ${e}`);
            }
        }
        return { files, errors };
    }
    formatIndex(rules) {
        const lines = [];
        lines.push('# Project Rules Index');
        lines.push('');
        lines.push('> Auto-generated by Monol Rulebook');
        lines.push('');
        // 카테고리별 요약
        const byCategory = new Map();
        for (const rule of rules) {
            const category = rule.category.split('/')[0];
            if (!byCategory.has(category)) {
                byCategory.set(category, []);
            }
            byCategory.get(category).push(rule);
        }
        lines.push('## Categories');
        lines.push('');
        for (const [category, catRules] of byCategory) {
            lines.push(`- **${category}** (${catRules.length} rules) - see \`${category}.mdc\``);
        }
        lines.push('');
        // 전체 규칙 목록
        lines.push('## All Rules');
        lines.push('');
        lines.push('| ID | Name | Severity | Category |');
        lines.push('|----|------|----------|----------|');
        for (const rule of rules) {
            const icon = getSeverityIcon(rule.severity);
            lines.push(`| ${rule.id} | ${rule.name} | ${icon} ${rule.severity} | ${rule.category} |`);
        }
        return lines.join('\n');
    }
    formatCategory(category, rules) {
        const lines = [];
        // MDC 프론트매터
        lines.push('---');
        lines.push(`description: ${this.capitalizeFirst(category)} 관련 규칙`);
        lines.push(`globs: ${this.getCategoryGlobs(category)}`);
        lines.push(`alwaysApply: ${category === 'workflow' ? 'true' : 'false'}`);
        lines.push('---');
        lines.push('');
        lines.push(`# ${this.capitalizeFirst(category)} Rules`);
        lines.push('');
        for (const rule of rules) {
            lines.push(this.formatRuleForClaude(rule));
            lines.push('');
            lines.push('---');
            lines.push('');
        }
        return lines.join('\n');
    }
    formatRuleForClaude(rule) {
        const lines = [];
        lines.push(`## ${rule.name}`);
        lines.push('');
        lines.push(`**ID:** \`${rule.id}\` | **Severity:** ${getSeverityIcon(rule.severity)} ${rule.severity}`);
        lines.push('');
        lines.push(rule.description.trim());
        lines.push('');
        if (rule.examples) {
            if (rule.examples.good && rule.examples.good.length > 0) {
                lines.push('### Correct');
                lines.push('```');
                for (const example of rule.examples.good) {
                    lines.push(example.trim());
                }
                lines.push('```');
                lines.push('');
            }
            if (rule.examples.bad && rule.examples.bad.length > 0) {
                lines.push('### Incorrect');
                lines.push('```');
                for (const example of rule.examples.bad) {
                    lines.push(example.trim());
                }
                lines.push('```');
                lines.push('');
            }
        }
        if (rule.exceptions && rule.exceptions.length > 0) {
            lines.push('### Exceptions');
            for (const exception of rule.exceptions) {
                lines.push(`- ${exception}`);
            }
            lines.push('');
        }
        return lines.join('\n');
    }
    formatAllRules(rules) {
        const lines = [];
        lines.push('---');
        lines.push('description: Project coding rules');
        lines.push('globs: **/*');
        lines.push('alwaysApply: true');
        lines.push('---');
        lines.push('');
        lines.push('# Project Rules');
        lines.push('');
        for (const rule of rules) {
            lines.push(this.formatRuleForClaude(rule));
            lines.push('');
            lines.push('---');
            lines.push('');
        }
        return lines.join('\n');
    }
    getCategoryGlobs(category) {
        const globMap = {
            code: '**/*.{ts,tsx,js,jsx,py,go,rs}',
            workflow: '.github/**/*,*.yaml,*.yml',
            style: '**/*.{css,scss,less,styled.ts}',
            docs: '**/*.{md,mdx}',
        };
        return globMap[category] || '**/*';
    }
    capitalizeFirst(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    }
}
// 어댑터 등록
registerAdapter('claude', ClaudeAdapter);
export default ClaudeAdapter;
//# sourceMappingURL=claude-adapter.js.map